<html>
<head>
<link rel="stylesheet" type="text/css" href="../styles/rao_general.css">
<link rel="stylesheet" href="../styles/rao_highlight.css">
<meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
<script src="../scripts/thirdparty/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script src="../scripts/thirdparty/jquery-2.1.4.min.js"></script>
<script src="../scripts/table_of_contents.js"></script>
</head>
<body>
<h2>Результаты моделирования</h2>
<p>Результаты моделирования (собираемые показатели) описываются с помощью ключевого слова <code class="rao">result</code>.</p>
<pre><code class="rao">result <i>имя_результата</i> = Result.create(<i>источник_данных</i>, <i>алгоритм_обработки</i>, <i>режим_работы</i>)</code></pre>
<p>Источник данных показывает какие данные собираются, алгоритм обработки - в каком виде отображаются результаты в конце прогона, а режим работы позволяет переключаться между автоматическим и ручны сбором статистики (по умолчанию, режим включается автоматический режим)</p>
<a id=data_source></a>
<h3>Источники данных</h3>
<p>Наблюдаемая величина может быть описана в источнике данных. Общий вид</p>
<pre><code class="rao">dataSource <i>Имя_истоника_данных</i>&lt;<i>тип_наблюдаемой_величины</i>&gt;(<i>параметры</i>) {
    def evaluate() {
        return <i>значение</i>
    }

    def condition() {
        return <i>условие_наблюдения</i>
    }
}
</code></pre>
<p>Для простых источников данных существует короткая запись, в следующем примере <i>результат1</i> и <i>результат2</i> эквивалентны</p>
<pre><code class="rao">dataSource <i>Имя_истоника_данных</i>&lt;<i>тип_наблюдаемой_величины</i>&gt;() {
    def evaluate() {
        return <i>наблюдаемая_величина</i>
    }

    def condition() {
        return true;
    }
}

result <i>результат1</i> = Result.create(<i>Имя_истоника_данных</i>, <i>алгоритм_обработки</i>)

result <i>результат2</i> = Result.create([<i>наблюдаемая_величина</i>], <i>алгоритм_обработки</i>)
</code></pre>
<a id=statistics></a>
<h3>Алгоритмы обработки данных</h3>
<table style="width:100%">
    <tr>
        <th width="20%">Тип статистики</th>
        <th width="20%">Поддерживаемые типы данных</th>
        <th width="60%">Описание</th>
    </tr>
    <tr>
        <td><pre><code class="rao">CategoricalStatistics</code></pre></td>
        <td>Все доступные(*)</td>
        <td>Статистика по перечислимым данным: категориям, состояниям или типам. Может быть применима к числовым данным с конечным количеством значений. Выводимые показатели: Самый длительный и самый короткий участки вхождения, общее время вхождения и процентное соотношение от общего времени моделирования для каждого зарегистрированного значения.</td>
    </tr>
    <tr>
        <td><pre><code class="rao">StorelessNumericStatistics</code></pre></td>
        <td><pre><code class="rao">int, double</code></pre></td>
        <td>Статистика для числовых данных. Выводимые показатели: скользящее среднее, стандартное отклонение, коэффициент вариации и последнее зарегистрированное значение </td>
    </tr>
    <tr>
        <td><pre><code class="rao">WeightedStorelessNumericStatistics</code></pre></td>
        <td><pre><code class="rao">int, double</code></pre></td>
        <td>Статистика для числовых данных, взвешенная по времени. Выводимые показатели: скользящее взвешенное среднее, стандартное отклонение, коэффициент вариации и последнее зарегистрированное значение. В качестве весового коэффициента применяется времянной промежуток устойчивого значения.</td>
    </tr>
    <tr>
        <td><pre><code class="rao">LastValueStatistics</code></pre></td>
        <td>Все доступные</td>
        <td>Статистика, выводящая последнее зарегестрированное значение.</td>
    </tr>
    <tr>
        <td><pre><code class="rao">LogStatistic</code></pre></td>
        <td>Все доступные</td>
        <td>Статистика, записывающая каждое изменение значения источника данных в файл в паре с временной меткой</td>
    </tr>
</table>
<p><pre>(*) Поддерживаемые естественно:
<code class="rao">boolean, String, enum</code></pre></p>
<p>При создании результата не обязательно указывать алгоритм обработки, в таком случае он будет выбран автоматически</p>
<pre><code class="rao">result <i>имя_результата</i> = Result.create([<i>наблюдаемая_величина</i>])
result <i>имя_результата</i> = Result.create([<i>наблюдаемая_величина</i>], <i>алгоритм_обработки</i>)
result <i>имя_результата</i> = Result.create(<i>источник_данных</i>)
result <i>имя_результата</i> = Result.create(<i>источник_данных</i>, <i>алгоритм_обработки</i>)
</code></pre>
<h4>Значения по умолчанию</h4>
<table style="width:100%">
    <tr>
        <th width="33%"><pre><code class="rao">int, double</code></pre></th>
        <th width="33%"><pre><code class="rao">boolean, String, enum</code></pre></th>
        <th width="33%"><pre><code class="rao">Остальные</code></pre></th>
    </tr>
    <tr>
        <td><pre><code class="rao">WeightedStorelessNumericStatistics</code></pre></td>
        <td><pre><code class="rao">CategoricalStatistics</code></pre></td>
        <td><pre><code class="rao">LastValueStatistics</code></pre></td>
    </tr>
</table>
<h4>Отличие взвешенной и обычной статистик для числовых значений</h4>
<p>Применим WeightedStorelessNumericStatistics и StorelessNumericStatistics к одному и тому же источнику данных</p>
<img src="../resources/images/numeric_statistics_comparison.png" alt="numeric_statistics_comparison"/>
<p>Отличие обусловленно тем, что очередь в 2 человека была дольше остальных значений 0 и 1, а в качестве весового коэффициента применяется времянной промежуток устойчивого значения. Это актуально для таких показателей, как длина очереди и коэффициент загрузки. Если же статистику необходимо собирать не учитывая весовой коэффициент времени, а только по факту вхождения, например, время обслуживания, следут использовать StorelessNumericStatistics, необходимо также учитывать, что при автоматическом подсчете результаты обновляются по каждому событию, что может влиять на статистику.</p>
<h3>Примеры собираемых показателей</h3>
<p>Рассмотрим сбор показателей на примере модели парикмахерской (<a href="https://github.com/aurusov/raox-models/tree/master/barber/barber_simple">скачать</a>):</p>
<pre><code class="rao">enum Состояние_парикмахера {Свободен, Занят}

type Парикмахерские {
    Состояние_парикмахера состояние_парикмахера
    int количество_в_очереди
    int количество_обслуженных
}

resource парикмахерская = Парикмахерские.create(Состояние_парикмахера.Свободен, 0, 0)

event Приход_клиента() {
    Приход_клиента.plan(currentTime + интервал_прихода.next())
    парикмахерская.количество_в_очереди = парикмахерская.количество_в_очереди + 1
}

operation Обслуживание_клиента() {
    relevant парикмахерская_ = парикмахерская.onlyif [
        состояние_парикмахера == Состояние_парикмахера.Свободен &amp;&amp; количество_в_очереди > 0
    ]

    def begin() {
        парикмахерская_.количество_в_очереди = парикмахерская_.количество_в_очереди - 1
        парикмахерская_.состояние_парикмахера = Состояние_парикмахера.Занят
    }
    def duration() {
        return длительность_обслуживания.next()
    }
    def end() {
        парикмахерская_.состояние_парикмахера = Состояние_парикмахера.Свободен
        парикмахерская_.количество_обслуженных = парикмахерская_.количество_обслуженных + 1
    }
}

logic Model {
    activity обслуживание_клиента = new Activity(Обслуживание_клиента.create())
}

sequence интервал_прихода = new Exponential(123456789, 1 / 30.0)
sequence длительность_обслуживания = new Uniform(123456789, 20, 40)

def init() {
    Приход_клиента.plan(currentTime + интервал_прихода.next())
}

def terminateCondition() {
    return currentTime >= 7 * 12 * 60
}

result занятость_парикмахера = Result.create([парикмахерская.состояние_парикмахера])
result длина_очереди = Result.create([парикмахерская.количество_в_очереди])
result всего_обслужено = Result.create([парикмахерская.количество_обслуженных], new LastValueStatistics())
result пропускная_способность = Result.create([парикмахерская.количество_обслуженных / currentTime * 60])
result длительность_работы = Result.create([currentTime / 60], new LastValueStatistics())
</code></pre>

<a id=result_number></a>
<h3>Сбор статистики по целочисленным и вещественным значениям</h3>
<pre><code class="rao">result длина_очереди = Result.create([парикмахерская.количество_в_очереди])
result пропускная_способность = Result.create([парикмахерская.количество_обслуженных / currentTime * 60])
</code></pre>
<pre><code class="rao">test.test.длина_очереди
    Mean: 7.710473751427658                 // среднее
    Last value: 14.0                        // последнее наблюдаемое значение
    Standard deviation: 6.587789962425884   // стандартное отклонение
    varcoef: 562.8574584149715              // коэффициент вариации

test.test.пропускная_способность
    Mean: 1.5306493080233001
    Last value: 1.8162890483219594
    Standard deviation: 0.2811013236310973
    varcoef: 5.16238133274301
</code></pre>

<a id=result_enum></a>
<h3>Наблюдение за перечислимым типом</h3>
<p>В конце моделирования выдается статистика по каждому значению перечислимого типа</p>
<pre><code class="rao">result занятость_парикмахера = Result.create([парикмахерская.состояние_парикмахера])
</code></pre>
<pre><code class="rao">test.test.занятость_парикмахера
    Shortest "Занят": 18.333821107700714          // Минимальное время непрерывного нахождения в этом состоянии
    Time of "Занят": 4641.375345927483            // Общее время нахождения в этом состоянии
    Persent of "Занят": 0.918309282130679         // Процент от времени моделирования, когда парикмахер был Занят (загрузка)
    Longest "Занят": 39.72987141521912            // Максимальное время непрерывного нахождения в этом состоянии
    Shortest "Свободен": 0.0                      //                                 --//--
    Persent of "Свободен": 0.08169071786932089    //                                 --//--             был Свободен (простой)
    Longest "Свободен": 64.00600791078857         //                                 --//--
    Time of "Свободен": 412.8862587886029         //                                 --//--
</code></pre>

<h3>Значение в конце моделирования</h3>
<p>Запоминает последнее значение выражения</p>
<pre><code class="rao">result всего_обслужено = Result.create([парикмахерская.количество_обслуженных], new LastValueStatistics())
result длительность_работы = Result.create([currentTime / 60], new LastValueStatistics())
</code></pre>
<pre><code class="rao">test.test.всего_обслужено
    Last value: 153

test.test.длительность_работы
    Last value: 84.23769341193477
</code></pre>

<h4>Состояние парикмахера</h4>
<pre><code class="rao">dataSource Занятость_парикмахера&lt;Состояние_парикмахера&gt;() {
    def evaluate() {
        return парикмахерская.состояние_парикмахера
    }
}

result занятость_парикмахера_ds = Result.create(new Занятость_парикмахера())
</code></pre>

<p>Результаты аналогичны <a href="#result_number">краткой записи</a></p>
<pre><code class="rao">test.test.занятость_парикмахера_ds 
    Shortest "Занят": 18.333821107700714
    Time of "Занят": 4641.375345927483
    Persent of "Занят": 0.918309282130679
    Shortest "Свободен": 0.0
    Persent of "Свободен": 0.08169071786932089
    Longest "Занят": 39.72987141521912
    Longest "Свободен": 64.00600791078857
    Time of "Свободен": 412.8862587886029
</code></pre>

<h4>Состояние парикмахера с условием</h4>
<pre><code class="rao">dataSource Занятость_парикмахера_в_диапазоне&lt;Состояние_парикмахера&gt;(Double timeStart, Double timeEnd) {
    def evaluate() {
        return парикмахерская.состояние_парикмахера
    }

    def condition() {
        return timeStart &lt;= currentTime &amp;&amp; currentTime &lt;= timeEnd
    }
}

result занятость_парикмахера_ds_condition = Result.create(new Занятость_парикмахера_в_диапазоне(100.0, 200.0))
</code></pre>

<pre><code class="rao">test.test.занятость_парикмахера_ds_condition
    Shortest "Занят": 12.227689197605201
    Time of "Занят": 46.67274335689561
    Persent of "Занят": 0.6321616589546964
    Shortest "Свободен": 0.7996702405280303
    Persent of "Свободен": 0.36783834104530355
    Longest "Занят": 34.44505415929041
    Longest "Свободен": 26.357978827942333
    Time of "Свободен": 27.157649068470363
</code></pre>

<h4>Длина очереди</h4>
<pre><code class="rao">dataSource Количество_в_очереди&lt;Integer&gt;() {
    def evaluate() {
        return парикмахерская.количество_в_очереди
    }
}

result длина_очереди_ds = Result.create(new Количество_в_очереди())
</code></pre>

<p>Результаты аналогичны <a href="#result_number">краткой записи</a></p>
<pre><code class="rao">test.test.длина_очереди_ds
    Mean: 7.710473751427658
    Last value: 14.0
    Standard deviation: 6.587789962425884
    varcoef: 562.8574584149715
</code></pre>

<h4>Управляемый подсчет</h4>
<p>Можно собирать значения показателя в конкретные моменты. Для этого нужно указать параметр <code class="rao">ResultMode.MANUAL</code> при создании результата и использовать метод <code class="rao">update()</code> для подсчета.</p>
<pre><code class="rao">result занятость_парикмахера_manual = Result.create([парикмахерская.состояние_парикмахера], ResultMode.MANUAL)

event Приход_клиента() {
    Приход_клиента.plan(currentTime + интервал_прихода.next())
    парикмахерская.количество_в_очереди = парикмахерская.количество_в_очереди + 1
    if (100 &lt;= currentTime &amp;&amp; currentTime &lt;= 200) {
        занятость_парикмахера_manual.update()
    }
}

operation Обслуживание_клиента() {
    relevant парикмахерская_ = парикмахерская.onlyif [
        состояние_парикмахера == Состояние_парикмахера.Свободен &amp;&amp; количество_в_очереди > 0
    ]

    def begin() {
        парикмахерская_.количество_в_очереди = парикмахерская_.количество_в_очереди - 1
        парикмахерская_.состояние_парикмахера = Состояние_парикмахера.Занят
        if (100 &lt;= currentTime &amp;&amp; currentTime &lt;= 200) {
            занятость_парикмахера_manual.update()
        }
    }
    def duration() {
        return длительность_обслуживания.next()
    }
    def end() {
        парикмахерская_.состояние_парикмахера = Состояние_парикмахера.Свободен
        парикмахерская_.количество_обслуженных = парикмахерская_.количество_обслуженных + 1
        if (100 &lt;= currentTime &amp;&amp; currentTime &lt;= 200) {
            занятость_парикмахера_manual.update()
        }
    }
}
</code></pre>

<pre><code class="rao">test.test.занятость_парикмахера_manual
    Shortest "Занят": 0.0
    Time of "Занят": 34.44505415929041
    Persent of "Занят": 0.5591484197038941
    Shortest "Свободен": 0.7996702405280303
    Persent of "Свободен": 0.44085158029610594
    Longest "Занят": 34.44505415929041
    Longest "Свободен": 26.357978827942333
    Time of "Свободен": 27.157649068470363
</code></pre>

<p>Кроме того можно собирать показатели без конкретного источника данных, для этого при создании нужно указать лишь один параметр <code><i>алгоритм_обработки</i></code></p>
<pre><code class="rao">result время_обслуживания = Result.create(new StorelessNumericStatistics())

operation Обслуживание_клиента() {
    relevant парикмахерская_ = парикмахерская.onlyif [
        состояние_парикмахера == Состояние_парикмахера.Свободен &amp;&amp; количество_в_очереди > 0
    ]

    def begin() {
        парикмахерская_.количество_в_очереди = парикмахерская_.количество_в_очереди - 1
        парикмахерская_.состояние_парикмахера = Состояние_парикмахера.Занят
    }
    def duration() {
        var next_darutaion =  длительность_обслуживания.next()
		время_обслуживания.update(next_darutaion)
		return next_darutaion
    }
    def end() {
        парикмахерская_.состояние_парикмахера = Состояние_парикмахера.Свободен
        парикмахерская_.количество_обслуженных = парикмахерская_.количество_обслуженных + 1
    }
}
</code></pre>
<pre><code class="rao">test.test.время_обслуживания
    Mean: 30.212485783395774
    Last value: 29.68128582317053
    Standard deviation: 5.690516657551401
    varcoef: 103.18078632649567
</code></pre>

</body>
</html>
