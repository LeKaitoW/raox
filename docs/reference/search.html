<html>
<head>
<link rel="stylesheet" type="text/css" href="../styles/rao_general.css">
<link rel="stylesheet" href="../styles/rao_highlight.css">
<meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
<script src="../scripts/thirdparty/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script src="../scripts/thirdparty/jquery-2.1.4.min.js"></script>
<script src="../scripts/table_of_contents.js"></script>
</head>
<body>
<h2>Поиск решения на графе</h2>
<p>Описание поиска решения имеет следующий вид:</p>
<pre><code class="rao">search <i>Имя_поиска_решения</i> {
    set init() {
        <i>инициализация_поиска</i>
    }
    <i>список_правил_для_порождения_вершин</i>
}
</code></pre>
<h3>Инициализация поиска</h3>
<p>Внутри метода <code class="rao">init()</code> могут быть установлены:</p>
<table style="width:100%">
    <tr>
        <th width="40%">Параметр</th>
        <th width="60%">Описание</th>
    </tr>
    <tr>
        <td><pre><code class="rao">parent = <i>имя_родительской_группы</i></code></pre></td>
        <td>Задаёт родительскую группы. Поиск на графе может осуществляться в рамках <a href="logic.html">группы активностей</a>. Если условие для группы не выполняется, то поиск не запускается.</td>
    </tr>
    <tr>
        <td><pre><code class="rao">startCondition = [<i>логическое_выражение</i>]</code></pre></td>
        <td>Задаёт условие начала поиска. Если условие не задано вообще, поиск будет проводиться безусловно.</td>
    </tr>
    <tr>
        <td><pre><code class="rao">terminateCondition = [<i>логическое_выражение</i>]</code></pre></td>
        <td>Задаёт условие окончания поиска. Когда алгоритм поиска на графе выбирает очередную вершину для раскрытия, проверяется, не удовлетворяет ли состояние системы, соответствующее этой вершине, условию окончания поиска. Если удовлетворяет, то решение найдено, поиск прекращается.</td>
    </tr>
    <tr>
        <td><pre><code class="rao">heuristic = [<i>арифметическое_выражение</i>]</code></pre></td>
        <td>Эвристическая оценка стоимости оставшегося пути на графе до целевой вершины.</td>
    </tr>
    <tr>
        <td><pre><code class="rao">compareTops = true/false</code></pre></td>
        <td>Если <code class="rao">true</code>, то в процессе поиска каждая вновь порожденная вершина сравнивается с уже присутствующими в графе. Если вершина повторяет одну из уже рассмотренных, она повторно не рассматривается и не добавляется в граф.</td>
    </tr>
</table>
<h3>Список правил для порождения вершин</h3>
<p>Правила, порождающие вершины графа поиска, могут быть образцами только типа <code class="rao">rule</code>. Для каждого правила необходимо указать стоимость его применения. Общий вид:</p>
<pre><code class="rao">edge <i>имя_правила</i> = new Edge(<i>Имя_образца_типа_rule</i>.create(<i>параметры_образца</i>), <i>стоимость_применения_правила</i>)</code></pre>
<p>Ниже приведен пример поиска решения для игры 5 (упрощенной версии <a href="https://ru.wikipedia.org/wiki/Игра_в_15">пятнашек</a> с 5 фишками вместо 15). Условием начала поиска является существование хоть одной фишки, находящейся не на своём месте. Условие окончание поиска - все фишки находятся на своих местах. Вновь порожденные вершины сравниваются с уже существующими, чтобы избежать зацикливания поиска. Эвристическая оценка задана нулем для всех вершин графа - в этом случае производится поиск в ширину.</p>
<pre><code class="rao">enum Место_дырки {СПРАВА, СЛЕВА, СВЕРХУ, СНИЗУ, ДЫРКИ_РЯДОМ_НЕТ}

type Фишки {
    int номер;
    int место;
}

type Дырка {
    int место;
}

resource фишка1 = Фишки.create(1, 2);
resource фишка2 = Фишки.create(2, 3);
resource фишка3 = Фишки.create(3, 6);
resource фишка4 = Фишки.create(4, 4);
resource фишка5 = Фишки.create(5, 5);
resource дырка = Дырка.create(1);

rule Перемещение_фишки (Место_дырки куда_перемещать, int на_сколько_перемещать) {
    relevant _фишка = Фишки.accessible.filter[где_дырка(место) == куда_перемещать].any();
    relevant _дырка = дырка;

    set execute() {
        _фишка.место = _фишка.место + на_сколько_перемещать;
        _дырка.место = _дырка.место - на_сколько_перемещать;
    }
}

constant длина_поля = 3;

int ряд(int место) {
    return (место - 1 ) / длина_поля + 1
}

int столбец(int место) {
    return (место - 1) % длина_поля + 1
}

Место_дырки где_дырка(int место) {
    if (столбец(место) == столбец(дырка.место) &amp;&amp; ряд(место) == ряд(дырка.место) + 1)
        return Место_дырки.СВЕРХУ

    if (столбец(место) == столбец(дырка.место) &amp;&amp; ряд(место) == ряд(дырка.место) - 1)
        return Место_дырки.СНИЗУ

    if (ряд(место) == ряд(дырка.место) &amp;&amp; столбец(место) == столбец(дырка.место) - 1)
        return Место_дырки.СПРАВА

    if (ряд(место) == ряд(дырка.место) &amp;&amp; столбец(место) == столбец(дырка.место) + 1)
        return Место_дырки.СЛЕВА

    return Место_дырки.ДЫРКИ_РЯДОМ_НЕТ
}

search Расстановка_фишек {
    edge перемещение_вправо = new Edge(Перемещение_фишки.create(Место_дырки.СПРАВА, 1), 1)
    edge перемещение_влево = new Edge(Перемещение_фишки.create(Место_дырки.СЛЕВА, -1), 1)
    edge перемещение_вверх = new Edge(Перемещение_фишки.create(Место_дырки.СВЕРХУ, -длина_поля), 1)
    edge перемещение_вниз = new Edge(Перемещение_фишки.create(Место_дырки.СНИЗУ, длина_поля), 1)

    set init() {
        startCondition = [Фишки.accessible.exists[номер != место]]
        terminateCondition = [Фишки.accessible.forall[номер == место]]
        heuristic = [0.0]
        compareTops = true
    }
}
</code></pre>
<p>Из исходной раскладки модель находит решение за три хода:</p>
<pre><code class="rao">ES 0.0 Tracing started
RC 0.0 фишка1 = {1, 2}
RC 0.0 фишка2 = {2, 3}
RC 0.0 фишка3 = {3, 6}
RC 0.0 фишка4 = {4, 4}
RC 0.0 фишка5 = {5, 5}
RC 0.0 дырка = {1}
ES 0.0 Simulation started
SB 0.0 Расстановка_фишек
SD  [1] перемещение_влево(фишка1, дырка)
SD  [3] перемещение_влево(фишка2, дырка)
SD  [6] перемещение_вверх(фишка3, дырка)
SES 0.0 solution cost = 3.0, nodes opened = 7, nodes total = 11, nodes added = 11, nodes spawned = 15
ES 0.0 Simulation finished: no more events
</code></pre>
</body>
</html>
