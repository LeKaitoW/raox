<html>
<head>
<link rel="stylesheet" type="text/css" href="../styles/rao_general.css">
<link rel="stylesheet" href="../styles/rao_highlight.css">
<meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
<script src="../scripts/thirdparty/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script src="../scripts/thirdparty/jquery-2.1.4.min.js"></script>
<script src="../scripts/table_of_contents.js"></script>
</head>
<body>
<h2>Образцы</h2>
<p>Образцы формируют часть базы знаний модели, позволяющую реализовать подход сканирования активностей. Они представляют собой набор правил и предусловий их выполнения, изменяющих состояние модели.</p>
<p>Описание образцов имеет следующий вид:</p>
<pre><code class="rao"><i>тип_образца</i> <i>Имя_образца</i>(<i>описание_параметров_образца</i>) {
    <i>описание_релевантных_ресурсов_образца</i>
    <i>тело_образца</i>
}</code></pre>
<p>Определены образцы двух типов:</p>
<table style="width:100%">
    <tr>
        <th width="20%">Тип образца</th>
        <th width="80%">Описание</th>
    </tr>
    <tr>
        <td><pre><code class="rao">operation</code></pre></td>
        <td>Описывают модифицированные продукционные правила, учитывающие временные связи</td>
    </tr>
    <tr>
        <td><pre><code class="rao">rule</code></pre></td>
        <td>Описывают обычные продукционные правила</td>
    </tr>
</table>
<h3>Образцы типа operation</h3>
<p>В теле образцов типа <code class="rao">operation</code> описываются инструкции, выполняемые в начале и в конце операции, а также вычисления её длительности:</p>
<table style="width:100%">
    <tr>
        <th width="30%">Имя метода</th>
        <th width="70%">Описание</th>
    </tr>
    <tr>
        <td><pre><code class="rao">begin()</code></pre></td>
        <td>Описание инструкций, которые должны выполняться в начале выполнения операций</td>
    </tr>
    <tr>
        <td><pre><code class="rao">duration()</code></pre></td>
        <td>Задание длительности выполнения операций</td>
    </tr>
    <tr>
        <td><pre><code class="rao">end()</code></pre></td>
        <td>Описание инструкций, которые должны выполняться в конце выполнения операций</td>
    </tr>
</table>
<p>Если длительность не задана, она принимается равной нулю. Если не заданы методы <code class="rao">begin</code> или <code class="rao">end</code>, то в начале и в конце операции соответственно состояние модели не меняется. Пример операции в разделе выбора релевантных ресурсов.</p>
<h3>Образцы типа rule</h3>
<p>В теле образцов типа <code class="rao">rule</code> определяется один метод:</p>
<table style="width:100%">
    <tr>
        <th width="30%">Имя метода</th>
        <th width="70%">Описание</th>
    </tr>
    <tr>
        <td><pre><code class="rao">execute()</code></pre></td>
        <td>Описание инструкций, которые должны быть выполнены в момент выполнения образца</td>
    </tr>
</table>
<pre><code class="rao">rule Вывоз_обработанных_деталей() {
    relevant обработанная_деталь = Деталь.accessible.filter[состояние == Состояние_детали.обработана].any

    def execute() {
        обработанная_деталь.erase()
    }
}
</code></pre>
<h3>Условие запуска, релевантные ресурсы</h3>
<p>Образец может быть запущен в результате успешного подбора всех описанных в нем релевантных ресурсов. Конструкция подбора каждого релевантного ресурса одинакова для всех типов образцов и имеет следующий вид:</p>
<pre><code class="rao">relevant <i>имя_релевантного_ресурса</i> = <i>правило_подбора_ресурса</i></code></pre>
<h4>Конкретный ресурс в качестве релевантного</h4>
<p>Рассмотрим случай, когда необходимо использовать конкретный ресурс в виде релевантного:</p>
<pre><code class="rao">relevant станок = станок_3.onlyif[состояние == Состояние_станка.ЗАКОНЧИЛ_ОБРАБОТКУ]</code></pre>
<p>Общий вид:</p>
<pre><code class="rao">relevant имя_релевантного_ресурса = имя_существующего_ресурса.onlyif[<i>условие_отбора</i>]</code></pre>
<h4>Подбор релевантного ресурса из ресурсов указанного типа</h4>
<p>Релевантным может стать может стать один ресурс указанного типа, например:</p>
<pre><code class="rao">enum Состояние_станка {свободен, загружается, готов_к_обработке}

type Станок {
    int номер
    Состояние_станка состояние
}

resource станок_1 = Станок.create(1, Состояние_станка.загружается)
resource станок_2 = Станок.create(2, Состояние_станка.свободен)
resource станок_3 = Станок.create(3, Состояние_станка.свободен)
resource станок_4 = Станок.create(4, Состояние_станка.готов_к_обработке)

operation Этап_обработки() {
    // Подбор любого станка из имеющихся, будет выбран станок_1
    relevant исполнительный_станок_1 = Станок.accessible.any

    // Подбор любого свободного станка, будет выбран станок_2
    relevant исполнительный_станок_2 = Станок.accessible.filter[состояние == Состояние_станка.свободен].any

    // Подбор свободного станка с максимальным номером, будет выбран станок_3
    relevant исполнительный_станок_3 = Станок.accessible.filter[состояние == Состояние_станка.свободен].maxBySafe[номер]

    // ...
}
</code></pre>
<p>Общий вид:</p>
<pre><code class="rao">relevant имя_релевантного_ресурса = Имя_типа.accessible.filter[<i>условие_отбора</i>].&lt;критерий_выбора_единственного_ресурса&gt;</code></pre>
<p>Сначала все доступные (<code class="rao">accessible</code>) ресурсы указанного типа проходят фильтрацию (<code class="rao">filter</code>). В результате формируется список, каждый ресурс которого является претендентом, чтобы стать релевантным. Из них нужно выбрать одного. Отбор происходит с помощью следующих методов:</p>
<table style="width:100%">
    <tr>
        <th width="40%">Имя метода</th>
        <th width="60%">Описание</th>
    </tr>
    <tr>
        <td><pre><code class="rao">any</code></pre></td>
        <td>Выбор любого ресурса из группы. Как правило, первого, но это не гарантируется. Самый быстрый отбор.</td>
    </tr>
    <tr>
        <td><pre><code class="rao">minBySafe[<i>арифметическое_выражение</i>]</code></pre></td>
        <td>Выбор ресурса, для которого указанное арифметическое выражение имеет наименьшее значение</td>
    </tr>
    <tr>
        <td><pre><code class="rao">maxBySafe[<i>арифметическое_выражение</i>]</code></pre></td>
        <td>Выбор ресурса, для которого указанное арифметическое выражение имеет наибольшее значение</td>
    </tr>
</table>

<h4>А доступен ли ресурс ?</h4>
<p>Как правило, фильтры применяются к <code>accessible</code> ресурсам. Это те ресурсы, которые не используются в качестве релевантных ни в одной активности. Если нужно выбирать среди все ресурсов, то используйте ключевое слово <code>all</code>. Тогда один ресурс может стать используемым в двух разных активностях.</p>
<pre><code class="rao">relevant имя_релевантного_ресурса = Имя_типа.all.filter[<i>условие_отбора</i>].&lt;критерий_выбора_единственного_ресурса&gt;</code></pre>
<p>Если в качестве релевантного подбирается конкретный ресурс, то его доступность можно проверить так:</p>
<pre><code class="rao">relevant станок = станок_3.onlyif[accessible &amp;&amp; состояние == Состояние_станка.ЗАКОНЧИЛ_ОБРАБОТКУ]</code></pre>
<p>Если <code>accessible</code> не указан, то ресурс может быть повторно выбран в качестве релевантного и стать используемым в двух разных активностях.</p>

<h4>Групповой подбор релевантных ресурсов</h4>
<h5>Ошибка последовательного выбора</h5>
<p>Релевантные ресурсы выбираются последовательно и без возвращений, т.е. выбранный ресурс не будет перевыбран. Это может привести к проблеме: при подборе следующего ресурса окажется, что образец не может быть выполнен из-за неудачного подбора предыдущего. Например:</p>
<pre><code class="rao">enum Состояние_детали {ожидает_обработки, обрабатывается, обработана}
type Деталь {
    Тип_обработки тип_обработки
    Состояние_детали состояние
    double длительность_обработки
}

enum Тип_обработки {токарная, фрезерная}
enum Состояние_станка {свободен, работает}
type Станок {
    Тип_обработки тип_обработки
    Состояние_станка состояние
}

resource деталь_1 = Деталь.create(Тип_обработки.токарная, Состояние_детали.ожидает_обработки, 10)
resource деталь_2 = Деталь.create(Тип_обработки.токарная, Состояние_детали.ожидает_обработки, 20)
resource деталь_3 = Деталь.create(Тип_обработки.фрезерная, Состояние_детали.ожидает_обработки, 40)

resource станок_1 = Станок.create(Тип_обработки.токарная, Состояние_станка.свободен)
resource станок_2 = Станок.create(Тип_обработки.фрезерная, Состояние_станка.свободен)

operation Обработка() {
    relevant деталь = Деталь.accessible.filter[состояние == Состояние_детали.ожидает_обработки].minBySafe [
        длительность_обработки
    ]
    relevant станок = Станок.accessible.filter [
        тип_обработки == деталь.тип_обработки &amp;&amp; состояние == Состояние_станка.свободен
    ].any

    def begin() {
        деталь.состояние = Состояние_детали.обрабатывается
        станок.состояние = Состояние_станка.работает
    }

    def duration() {
        return деталь.длительность_обработки
    }

    def end() {
        деталь.состояние = Состояние_детали.обработана
        станок.состояние = Состояние_станка.свободен
    }
}

logic Model {
    activity обработка = new Activity(Обработка.create())
}
</code></pre>
<p>Ожидается, что в нулевой момент времени начнутся две операции - токарная для первой детали и фрезерная для третьей. Но <a href="../debug/trace.html">трассировка</a> говорит о другом, см. левую часть:</p>
<table style="width: 100%">
    <tr>
        <td><p>Ошибка последовательного подбора</p></td>
        <td><p>Групповой подбор, ошибки нет</p></td>
    </tr>
    <tr>
        <td><pre><code class="rao">ES 0.0 Tracing started
RC 0.0 деталь_1 = {токарная, ожидает_обработки, 10.0}
RC 0.0 деталь_2 = {токарная, ожидает_обработки, 20.0}
RC 0.0 деталь_3 = {фрезерная, ожидает_обработки, 40.0}
RC 0.0 станок_1 = {токарная, свободен}
RC 0.0 станок_2 = {фрезерная, свободен}
ES 0.0 Simulation started
EB 0.0 обработка[0](деталь_1, станок_1)
RK 0.0 деталь_1 = {токарная, обрабатывается, 10.0}
RK 0.0 станок_1 = {токарная, работает}
EF 10.0 обработка[0](деталь_1, станок_1)
RK 10.0 деталь_1 = {токарная, обработана, 10.0}
RK 10.0 станок_1 = {токарная, свободен}
EB 10.0 обработка[1](деталь_2, станок_1)
RK 10.0 деталь_2 = {токарная, обрабатывается, 20.0}
RK 10.0 станок_1 = {токарная, работает}
EB 10.0 обработка[2](деталь_3, станок_2)
RK 10.0 деталь_3 = {фрезерная, обрабатывается, 40.0}
RK 10.0 станок_2 = {фрезерная, работает}
EF 30.0 обработка[1](деталь_2, станок_1)
RK 30.0 деталь_2 = {токарная, обработана, 20.0}
RK 30.0 станок_1 = {токарная, свободен}
EF 50.0 обработка[2](деталь_3, станок_2)
RK 50.0 деталь_3 = {фрезерная, обработана, 40.0}
RK 50.0 станок_2 = {фрезерная, свободен}
ES 50.0 Simulation finished: no more events
        </code></pre></td>
        <td><pre><code class="rao">ES 0.0 Tracing started
RC 0.0 деталь_1 = {токарная, ожидает_обработки, 10.0}
RC 0.0 деталь_2 = {токарная, ожидает_обработки, 20.0}
RC 0.0 деталь_3 = {фрезерная, ожидает_обработки, 40.0}
RC 0.0 станок_1 = {токарная, свободен}
RC 0.0 станок_2 = {фрезерная, свободен}
ES 0.0 Simulation started
EB 0.0 обработка[0](деталь_1, станок_1)
RK 0.0 деталь_1 = {токарная, обрабатывается, 10.0}
RK 0.0 станок_1 = {токарная, работает}
EB 0.0 обработка[1](деталь_3, станок_2)
RK 0.0 деталь_3 = {фрезерная, обрабатывается, 40.0}
RK 0.0 станок_2 = {фрезерная, работает}
EF 10.0 обработка[0](деталь_1, станок_1)
RK 10.0 деталь_1 = {токарная, обработана, 10.0}
RK 10.0 станок_1 = {токарная, свободен}
EB 10.0 обработка[2](деталь_2, станок_1)
RK 10.0 деталь_2 = {токарная, обрабатывается, 20.0}
RK 10.0 станок_1 = {токарная, работает}
EF 30.0 обработка[2](деталь_2, станок_1)
RK 30.0 деталь_2 = {токарная, обработана, 20.0}
RK 30.0 станок_1 = {токарная, свободен}
EF 40.0 обработка[1](деталь_3, станок_2)
RK 40.0 деталь_3 = {фрезерная, обработана, 40.0}
RK 40.0 станок_2 = {фрезерная, свободен}
ES 40.0 Simulation finished: no more events
        </code></pre></td>
    </tr>
</table>
<p>Разберемся с причинами. Первое сканировании, нулевой момент времени, поиск нужной детали. Под фильтр попадают все три, а с помощью <code class="rao">minBySafe</code> выбирается первая и закрепляется, как релевантная образцу. Фильтр по станкам возвращает только токарный станок из-за только что выбранной детали. Станок назначается релевантным, <code>операция[0]</code> запускается. Подход сканирования активностей опять проверяет возможность запуска операции, начинается подбор релевантных ресурсов. В этот раз фильтр возвращает вторую и третью детали. Критерий отбора выбирает вторую, т.к. её длительность меньше. Она закрепляется как релевантный операции ресурс. Начинается подбор станка. Из свободных только второй станок, но он фрезерный, а не токарный, т.е. не подходит к уже выбранной детали. Поэтому операция начаться не может. А третья деталь даже ну будет проверяться, потому что вторая уже закреплена как релевантная. На текущий момент времени больше не может начаться ни одна операция. Система переводит модельное время к ближайшему событию, т.е. на 10 минут - это событие конца первой операции. Оно выполняется, токарный станок становится свободным. Запускается сканирование новой операции, начинается подбор детали. Опять под фильтр попадают вторая и треться детали, опять выбирается вторая. Но теперь для неё находится свободный токарный станок, <code>операция[1]</code> запускается. Система сканирует, выбирает оставшуюся свободную деталь и находит подходящий к ней фрезерный станок. И вот только теперь запускается <code>операция[2]</code>. Это выглядит как ошибка. Её решением является групповой выбор ресурсов.</p>
<h5>Решение проблемы</h5>
<p>Чтобы избежать подобного, процедура подбора должна проанализировать все возможные комбинации. Для этого используется конструкция <code class="rao">relevantSet</code>. Конечно, это приводит к падению быстродействия.<br>Изменим выбор релевантных ресурсов:</p>
<pre><code class="rao">operation Обработка() {
    relevants деталь, станок = combination(
        Деталь.accessible.filter[состояние == Состояние_детали.ожидает_обработки],
        Станок.accessible.filter[состояние == Состояние_станка.свободен]
    ).filter[деталь.тип_обработки == станок.тип_обработки].minBySafe[деталь.длительность_обработки] of types Деталь, Станок

    def begin() {
        деталь.состояние = Состояние_детали.обрабатывается
        станок.состояние = Состояние_станка.работает
    }

    def duration() {
        return деталь.длительность_обработки
    }

    def end() {
        деталь.состояние = Состояние_детали.обработана
        станок.состояние = Состояние_станка.свободен
    }
}
</code></pre>
<p>Сначала будут подобраны все возможные пары из свободных станков и деталей, проверено соответствие их типов, а затем будет выбрана та пара, для которой время обработки детали минимально. В нулевой момент времени запускаются токарная и фрезерная операции, см. правую трассировку чуть выше. Теперь поведение выглядит ожидаемым.</p>
<h4>Итоговая модель с операцией и продукционным правилом</h4>
<pre><code class="rao">enum Состояние_детали {ожидает_обработки, обрабатывается, обработана}
type Деталь {
    Тип_обработки тип_обработки
    Состояние_детали состояние
    double длительность_обработки
}

enum Тип_обработки {токарная, фрезерная}
enum Состояние_станка {свободен, работает}
type Станок {
    Тип_обработки тип_обработки
    Состояние_станка состояние
}

resource деталь_1 = Деталь.create(Тип_обработки.токарная, Состояние_детали.ожидает_обработки, 10)
resource деталь_2 = Деталь.create(Тип_обработки.токарная, Состояние_детали.ожидает_обработки, 20)
resource деталь_3 = Деталь.create(Тип_обработки.фрезерная, Состояние_детали.ожидает_обработки, 40)

resource станок_1 = Станок.create(Тип_обработки.токарная, Состояние_станка.свободен)
resource станок_2 = Станок.create(Тип_обработки.фрезерная, Состояние_станка.свободен)

operation Обработка() {
    relevants деталь, станок = combination(
        Деталь.accessible.filter[состояние == Состояние_детали.ожидает_обработки],
        Станок.accessible.filter[состояние == Состояние_станка.свободен]
    ).filter[деталь.тип_обработки == станок.тип_обработки].minBySafe[деталь.длительность_обработки] of types Деталь, Станок

    def begin() {
        деталь.состояние = Состояние_детали.обрабатывается
        станок.состояние = Состояние_станка.работает
    }

    def duration() {
        return деталь.длительность_обработки
    }

    def end() {
        деталь.состояние = Состояние_детали.обработана
        станок.состояние = Состояние_станка.свободен
    }
}

rule Вывоз_обработанных_деталей() {
    relevant обработанная_деталь = Деталь.accessible.filter[состояние == Состояние_детали.обработана].any

    def execute() {
        обработанная_деталь.erase()
    }
}

logic Model {
    activity обработка = new Activity(Обработка.create())
    activity вывоз_обработанных_деталей = new Activity(Вывоз_обработанных_деталей.create())
}
</code></pre>
<pre><code class="rao">ES 0.0 Tracing started
RC 0.0 деталь_1 = {токарная, ожидает_обработки, 10.0}
RC 0.0 деталь_2 = {токарная, ожидает_обработки, 20.0}
RC 0.0 деталь_3 = {фрезерная, ожидает_обработки, 40.0}
RC 0.0 станок_1 = {токарная, свободен}
RC 0.0 станок_2 = {фрезерная, свободен}
ES 0.0 Simulation started
EB 0.0 обработка[0](деталь_1, станок_1)
RK 0.0 деталь_1 = {токарная, обрабатывается, 10.0}
RK 0.0 станок_1 = {токарная, работает}
EB 0.0 обработка[1](деталь_3, станок_2)
RK 0.0 деталь_3 = {фрезерная, обрабатывается, 40.0}
RK 0.0 станок_2 = {фрезерная, работает}
EF 10.0 обработка[0](деталь_1, станок_1)
RK 10.0 деталь_1 = {токарная, обработана, 10.0}
RK 10.0 станок_1 = {токарная, свободен}
EB 10.0 обработка[2](деталь_2, станок_1)
RK 10.0 деталь_2 = {токарная, обрабатывается, 20.0}
RK 10.0 станок_1 = {токарная, работает}
ER 10.0 вывоз_обработанных_деталей[0](деталь_1)
RE 10.0 деталь_1 = {токарная, обработана, 10.0}
EF 30.0 обработка[2](деталь_2, станок_1)
RK 30.0 деталь_2 = {токарная, обработана, 20.0}
RK 30.0 станок_1 = {токарная, свободен}
ER 30.0 вывоз_обработанных_деталей[1](деталь_2)
RE 30.0 деталь_2 = {токарная, обработана, 20.0}
EF 40.0 обработка[1](деталь_3, станок_2)
RK 40.0 деталь_3 = {фрезерная, обработана, 40.0}
RK 40.0 станок_2 = {фрезерная, свободен}
ER 40.0 вывоз_обработанных_деталей[2](деталь_3)
RE 40.0 деталь_3 = {фрезерная, обработана, 40.0}
ES 40.0 Simulation finished: no more events
</code></pre>
</body>
</html>
